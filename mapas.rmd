---
title: "Mapas no R!"
author: "Jessica Voigt"
date: "18 de junho de 2018"
output: html_document
---

Dados espaciais são dados organizados por localização. Vamos utilizar o cadastro de escolas que a Prefeitura Municipal de São Paulo disponibiliza aqui.


```{r, echo=TRUE, eval=FALSE, warning=FALSE, message=FALSE}

library(readr)
library(sf)
library(ggplot2)
library(mapview)
library(ggmap)
library(cepespR)
library(dplyr)
library(data.table)

#Dados escolas

url_cadatros_escolas <- "http://dados.prefeitura.sp.gov.br/dataset/8da55b0e-b385-4b54-9296-d0000014ddd5/resource/39db5031-7238-4139-bcaa-e620a3180188/download/escolasr34fev2017.csv"

download.file(url_cadatros_escolas, "temp.csv")

#Abrindo o arquivo
escolas <- fread("temp.csv")

glimpse(escolas)
```

Há uma dupla de variáveis que nos permite trabalhar "geograficamente" com os dados: LATITUDE e LONGITUDE. "Lat e Long" são a informação fundamental de um dos sistemas de coordenadas (coordinate reference system, CRS) mais utilizados para localização de objetos na superfície da terra.

Por uma razão desconhecida, a informação fornecida pela PMSP está em formato diferente do convencional. **Latitudes são representadas por números entre -90 e 90, com 8 casas decimais, e Longitudes por números entre -180 e 180, também com 8 casas decimais**. Em nosso par de variáveis, o separador de decimal está omitido e por esta razão faremos um pequena modificação na variável. Aproveitaremos também para renomear algumas variáveis de nosso interesse -- como tipo da escola (CEI, EMEI, EMEF, CEU, etc) e o ano de início do funcionamento::

```{r, echo=TRUE, eval=FALSE, warning=FALSE, message=FALSE}

escolas <- escolas  %>%
  rename(lat = LATITUDE, lon = LONGITUDE, tipo = TIPOESC) %>% 
  mutate(lat = lat / 1000000, 
         lon = lon / 1000000,
         ano = as.numeric(substr(DT_INI_FUNC, 7, 10))) %>%
  filter(is.na(lat)==FALSE & is.na(lon)==FALSE)

```

Temos agora uma informação geográfica das EMEFs e uma variável de interesse -- ano -- que utilizaremos para investigar a expansão da rede.

Para analisar estes dados como dados espaciais **precisamos dizer ao R quais são as variáveis de localização e transformá-lo em um objeto 'simple features' usando o biblioteca sf e a função st_as_sf para criar um objeto tipo "simple features"**.

```{r, echo=TRUE, eval=FALSE, warning=FALSE, message=FALSE}

# library(sf)
escolas <- escolas %>% 
  st_as_sf(coords=c("lon","lat"), crs=4326)

#Qual tipo de objeto é emef agora?
class(escolas)

```

O parâmetro 'coords' indica os colunas de latitude e longitude, e o 'crs' indica o sistema de coordenadas (a "projeção") que queremos usar. Na verdade, o sistema de coordenadas não é uma opção nossa - **precisamos especificar o mesmo sistema de coordenadas com o qual os dados foram salvos**. Às vezes isso é difícil de saber. Aqui, como o longitude e latitude parece que eles estão em graus (entre -180 e 180) é provável que devemos usar o sistema "WGS84" (um sistema de coordenadas geográficas (não projetadas)). **Um atalho para especificar o WGS84 é usar o numero 4326 no argumento 'crs'**. Para outros outros para sistemas de coordenados que pode usar com dados salvados em outros sistemas de coordenados, pode aproveitar do site http://epsg.io/. 

Temos vários resultados aqui - é um objeto 'simple features', mas também um tbl (tibble) e data.frame! 
Isso significa que podemos aplicar todas as funções do dplyr com dados espaciais também. 

Quando olhamos num objeto simple features, tem vários coisas importantes a observar:

1. Na descrição imprimido em Rstudio, podemos ver 'geometry type: POINT' - isso significa que cada elemento espacial é um ponto único (também pode ser um polígono ou linha);
2. O CRS (e o código epsg);
3. O número de 'features' (unidades espaciais) e 'fields' (variáveis/colunas);
4. No data.frame mesmo, temos duas colunas de NOMESC e SITUACAO, e uma terceira de 'geometry' (última coluna) - isso é uma coluna especial que contém as informações de localização para cada unidade. Aqui são as coordenadas dos nossos pontos.


### Visualizando mapas

Lembra que nossos gráficos em ggplot foram conectados diretamente com um data.frame? Como um objeto de 'simple features' é um data.frame, podemos usar ggplot para criar mapas! Para fazer isso, precisamos instalar a versão de desenvolvimento do ggplot2. Para visualizar o nosso mapa, **vamos usar uma camada de geometria especial (e espacial) se chama geom_sf, e o formato dos parâmetros são os mais simples possíveis: branco!**

```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}

emef <- escolas %>%
  filter(tipo == "EMEF") %>%
  select(NOMESC,SITUACAO)  # mesmo selecionando esses dois, ele não perde o geometry
  
emef %>%
ggplot() +  geom_sf()
```


Já criou o seu primeiro mapa! O eixo x é o longitude e o eixo y é o latitude. Debaixo, vamos ver como a representar outros aspectos de nosso data.frame em mapas. Agora, tem um outro abordagem para criar um mapa interativo, com um mapa de terra no fundo. Usamos o pacote 'mapview' e, de novo, não precisamos especificar nenhum parâmetro.

```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}

library(mapview)

emef %>%
  mapview()

```

### Exercício

Criar um mapa de escolas de tipo "EMEBS" (Escolas Municipais de Educação Bilíngue para Surdos).

```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}

# Vou começar desde o início, transformando o df em um sf:

# library(sf)
# library(dplyr)
# library(mapview)

escolas2 <- fread("temp.csv")

emebs <- escolas2  %>%
  rename(lat = LATITUDE, lon = LONGITUDE, tipo = TIPOESC) %>% 
  mutate(lat = lat / 1000000, 
         lon = lon / 1000000,
         ano = as.numeric(substr(DT_INI_FUNC, 7, 10))) %>%
  filter(!is.na(lat),
         !is.na(lon),
         tipo == "EMEBS") %>%
  st_as_sf(coords=c("lon","lat"), crs=4326)

emebs %>%
  mapview()
```


### Georeferencing

Um outro fonte de dados espaciais é georeferenciar um endereço usando uma ferramenta de busca como o google maps, por exemplo com o pacote ggmap.

Vamos agora criar um novo data frame a partir dos dados do cadastro da PMSP que contém apenas os CEUs. Vamos juntar todas as informações de endereço e agregar a elas o texto ", Sao Paulo, Brazil"


```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}

ceu <- escolas2  %>%
  rename(lat = LATITUDE, lon = LONGITUDE, tipo = TIPOESC) %>% 
  mutate(lat = lat / 1000000, 
         lon = lon / 1000000,
         ano = as.numeric(substr(DT_INI_FUNC, 7, 10))) %>%
  filter(!is.na(lat),
         !is.na(lon),
         tipo == "CEU") %>%
  mutate(endereco = paste(ENDERECO, NUMERO, BAIRRO, CEP, ", Sao Paulo, Brazil"))


```
Com a função geocode, procuraremos a latitude e longitude dos 46 CEUs. Vamos ver o exemplo do primeiro CEU, criando um objeto tipo 'sf' com o sistema de referência de coordenadas usado pelo google maps (WGS84 = epsg 4326):


```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}

library(ggmap)
library(sf)

ceu1 <- geocode(ceu$endereco[1]) %>%         # acha as coordenadas a partir do endereço
  st_as_sf(coords=c("lon","lat"),crs=4326)   # cria uma variável geometry

ceu1 %>% mapview()

```

Para georeferenciar todos os endereços de CEUs é a mesma lógica. Só precisamos resolver um problema de encoding irritante primeiro. Procuraremos a latitude e longitude dos 46 endereços, e tiramos aqueles que falharem (aqueles que tem NA):

```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}

ceu$endereco <- iconv(ceu$endereco, to = "ASCII//TRANSLIT")

ceu_all <- geocode(ceu$endereco ) %>% 
  filter(is.na(lat)==F & is.na(lon)==FALSE) %>%
  st_as_sf(coords=c("lon","lat"),crs=4326)

ceu_all %>% mapview()

```

Simples, não!

O principal problema da função geocode - e por que você pode ver menos de 46 pontos em seu mapa - é que há um limite de consultas por conta dos termos da Google Maps API. **A alternativa é usar como argumento de geocode "source = 'dsk'" Data Science Toolkit**, que reune uma série de fontes de dados e utiliza outra API para a consulta de latitude e longitude de logradouros.


### Exercício

Use a função geocode para geolocalizar três endereços com os quais você está familiarizado em São Paulo e criar um mapa com ggplot e um mapa interativa com mapview.

```{r, echo=TRUE, eval=TRUE, warning=FALSE, message=FALSE}



```


### Trabalhando com Polígonos

Áreas administrativas são geralmente representadas como polígonos em mapas. Em geral, obtemos esses polígonos como 'shapefiles' produzidos por uma agência oficial. Podemos abrir qualquer tipo de shapefile (pontos, linhas ou polígonos) com a função read_sf. Vamos abrir um shapefile (simplificado) de IBGE dos municipios do Brasil.

```{r}
download.file("https://github.com/JonnyPhillips/Curso_R/raw/master/Brazil_s.zip",destfile="Brazil_s.zip")

unzip("Brazil_s.zip")

municipios <- read_sf("Brazil_s.shp")
```

Como podemos visualizar este mapa? Exatamente o mesmo que antes:

```{r}

municipios %>% ggplot() +
  geom_sf()

```

Enquanto trabalhando com dados espaciais de diversas fontes (ex. as escolas e os municipios), é essencial ter certeza que estamos trabalhando com a mesma projeção para todos os objetos - caso contrário nossos mapas podem não aparecer corretamente e nossas medidas espaciais serão imprecisas. 

Dar uma olhada na CRS/projeção de 'municipios' - está escrito "+proj=longlat +ellps=GRS80 +no_defs" - em contraste de CRS/projeção de 'escolas' - "+proj=longlat +datum=WGS84 +no_defs". O parte 'WGS84' é o mais comum então vamos transformar os dados dos municipios para a mesma projeção usando a função st_transform e o shortcut 4326 para WGS84. 

Agora estamos tudo pronto para fazer analises ou mapas incorporando as duas camadas espaciais.

```{r}
municipios <- municipios %>% st_transform(4326)
```


### Joins Não-Espaciais

Se abre o objeto municipios vai ver os detalhes de CRS/projeção e o data.frame dele mesmo, incluindo a coluna de 'geometry' e também todas as colunas normais, incluindo o código municipal (CD_GEOCODM). Isso é uma oportunidade para nós - se tivermos dados em todos os municípios, podemos simplesmente 'join' estes dados no shapefile e, em seguida, podemos visualizar mapas dessas variáveis. <3

Por exemplo, vamos baixar os dados eleitorais de 2010 para cada município e calcular o percentagem de voto da Dilma no segundo turno.

```{r}
library(cepespR)

dados_eletorais <- get_elections(year=2010, position="President", regional_aggregation="Municipality", political_aggregation="Candidate")

dados_eletorais <- dados_eletorais %>% filter(NUM_TURNO==2) %>% 
  group_by(COD_MUN_IBGE) %>%
  mutate(pct_voto=100*(QTDE_VOTOS/sum(QTDE_VOTOS))) %>%
  filter(NOME_URNA_CANDIDATO=="DILMA")

```

Agora, se quisermos tornar esses dados eleitorais espaciais podemos fazer um left_join com o nosso shapefile, contanto que, como normal, os nomes e tipo de colunas chaves - o código do IBGE - nos dois bancos de dados são os mesmos.

```{r}

municipios <- municipios %>% 
  rename("COD_MUN_IBGE"="CD_GEOCODM") %>% 
  mutate(COD_MUN_IBGE=as.numeric(COD_MUN_IBGE)) %>%
  left_join(dados_eletorais,by="COD_MUN_IBGE")

#Geometry foi adicionada no municipios

municipios

```

Para visualizar a coluna 'pct_voto' num mapa, podemos trabalhar em ggplot como normal. Para polígonos, colocamos o nome de coluna para o parâmetro fill (color com pontos e linhas). Um mapa de todo o Brasil pode ser esmagador, então vamos nos concentrar em São Paulo com um filter.

```{r}

municipios %>% filter(SIGLA_UE=="SP") %>% 
  ggplot() +
  geom_sf(aes(fill=pct_voto))

```

Vamos destacar as fronteiras em branco, aplicar um tema e tirar as linhas de longitude/latitude.

```{r}

municipios %>% filter(SIGLA_UE=="SP") %>% 
  ggplot() +
  geom_sf(aes(fill=pct_voto),color="white") +
  theme_classic() +
  coord_sf(datum=NA)
```

Além disso, podemos alterar as escalas de cores como normal em ggplot.

```{r}

municipios %>% filter(SIGLA_UE=="SP") %>% 
  ggplot() +
  geom_sf(aes(fill=pct_voto),color="white") +
  theme_classic() +
  coord_sf(datum=NA) +
  scale_fill_gradient(low="white",high="red")

```

Podemos colocar os pontos no mesmo mapa? 

Sim - apenas especificamos o parâmetro de dados para uma nova camada dentro de geom_sf. (Isto assume que nós confirmamos que ambas as camadas têm a mesma projeção, como confirmamos acima).

```{r}

municipios %>% filter(SIGLA_UE=="SP") %>% 
  ggplot() +
  geom_sf(aes(fill=pct_voto),color="white") +
  theme_classic() +
  scale_fill_gradient(low="white",high="red") +
  geom_sf(data=ceu,color="dark green") +
  coord_sf(datum=NA)

# Não estou conseguindo terminar isso =(((

```

### Exercício

Crie um mapa do percentagem de voto de Serra nos municipios de Tocantins no segundo turno da eleição
presidencial de 2010.

Terminar : 

https://github.com/leobarone/FLS6397_2018/blob/master/tutorials/tutorial14.Rmd

https://github.com/leobarone/FLS6397_2018/blob/master/tutorials/tutorial22.Rmd
