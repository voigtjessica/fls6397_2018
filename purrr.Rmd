---
title: "Purrr"
author: "Jessica Voigt"
date: "25 de junho de 2018"
output: html_document
---

Essa é a última aula do curso e é sobre purrr.

Vamos carregar as bibliotecas, montar um DF de exemplo com 5% de NA

```{r, message=FALSE, warning=FALSE}

library(dplyr)
library(purrr)

df <- data_frame(x = sample(c(rnorm(95), rep(NA, 5)), 
                            1000, 
                            replace = T),
                 y = rnorm(1000, 42, 3),
                 z = rexp(1000, 1))

```

Vamos calcular as médias das colunas. Primeiro com o for loop:

```{r}

media_col <- c()
for (i in 1:ncol(df)){
  media_col <- c(media_col, mean(df[[i]], na.rm = T))
}
```

Leitura:

       1.cria o objeto de vetor media_col
       2.para cada i em 1 até o numero de colunas de df, media col recebe media col + média da coluna do df naquele momento, retirar NA = TRUE

Uma alternativa ligeiramente mais eficiente é determinar antes do loop o tamanho do objeto que conterá o resultado e a cada i-ésima itearação adicionar a média calculada à i-ésima posição deste objeto:

```{r}
media_col <- vector("double", ncol(df))
for (i in 1:ncol(df)){
  media_col[[i]] <- mean(df[[i]], na.rm = T)
}
```

Em ambos os casos temos um bocado de código para uma tarefa bastante simples. A partir de agora, esqueceremos o for loop e aprenderemos um pouco sobre as funções da família "map" que são utlizadas em programação funcional como substitutas de loops.

O uso básico do pacote purrr, para resolver o problema acima é:

```{r}
x <- map(df, mean, na.rm=TRUE)
```

### Função MAP

A função map pode ser aplicada a uma lista, a um data frame (que é uma lista de vetores na vertical e pareados) ou a um vetor **e, para cada posição da lista/data frame/vetor aplica uma função**. O resultado é uma lista de tais aplicações. Note que o resultado da função acima é uma lista.

**As variações da função map permite que o resultado seja outra classe de objeto** que não uma lista. map_dbl, por exemplo, retorna um vetor do tipo "double". Diferentemente de map, as funções da família que especificam a classe de output precisam que a função aplicada a cada elemento também retorne tal classe.

```{r}
map_dbl(df, mean, na.rm=TRUE)
```

Para adicionar parâmatros à função mean, que aplicamos com map_dbl, basta separá-los com vírgula, em ordem, após a função aplicada:

```{r}
#Para calcularmos o desvio padrão:
map_dbl(df, sd, na.rm = T)

#Ou o primeiro decil:
map_dbl(df, quantile, probs = 0.1, na.rm = T)

#ou o primeiro e último decil:
map_dbl(df, quantile, probs = c(0.1, 0.9), na.rm = T)
```

Ops! Aqui deu errado. O que aconteceu?

A função map_dbl requer que o output seja um vetor atômico do tipo double. Nesse caso, ao aplicarmos a função quantile e escolhermos 2 decis, temos como resultado um vetor de tamanho 2. O resultado da iteração não pode, por essa razão, ser um vetor. Pode ser, porém, uma lista:

```{r}

map(df, quantile, probs = c(0.1, 0.9), na.rm = T)

```

A função map sempre servirá onde alguma outra da família servir. Na dúvida, use-a.

Vamos a outro exemplo. Peguemos o data frame "starwas", disponível no pacote dataset.

```{r}

library(datasets)
data("starwars")    
        
```

O data frame contém informações sobre cada um dos personagens da série de filmes. Como é de se esperar, algumas variáveis deste dataset não devem ser numéricas. Como investigamos quais variáveis são numéricas?

```{r}

map_lgl(starwars, is.numeric)

```

Simples, não? Com map_lgl aplicamos a função is.numeric a todas as variáveis e obtemos como resultado um vetor lógico que contém a informação de quais variávais são numéricas. Poderíamos utilizá-lo, por exemplo, para selecionar apenas as variáveis numéricas do dataset e calcularmos a média:

```{r}
numerica <- map_lgl(starwars, is.numeric)
map_dbl(starwars[, numerica], mean, na.rm = T)
```

Algo semelhante pode ser feito com o "typeof", que retorna o tipo da variável. Este informação, porém, é textual, e por isso utilizamos a função map_chr para aplicá-la a todos os elementos do data frame (ou lista, ou vetor):

```{r}
map_chr(starwars, typeof)
```

As funções aplicadas à uma lista (ou data frame ou vetor) não precisam, como vimos no exemplo da função quantiles ter outputs "simples":

```{r}
map(df, summary)
```

Podemos, inclusive, criar funções e aplicá-las com map. Vamos resgatar o data frame "mtcars", bastante utilizado para fins didáticos em R e que vimos no início do curso:

```{r}
data(mtcars)
?mtcars

amplitude <- function(x) {
  max(x) - min(x) 
}

map(mtcars, amplitude)
```

Então no caso eu fiz uma função e fiz o loop com o map.

Note que, não precisamos criar a função para aplicá-la com map. Se quisermos, podemos utilizar funções anônimas, ou seja, que não são geradas como objeto, mas sim criadas no contexto de sua aplicação, o que poupa bastante cógido.

```{r}
map(mtcars, function(x) max(x)- min(x))
```

Para tornar o código ainda mais curto e eliminar obviedades, podemos utilizar o símbolo "~" para indicar que haverá na sequência uma função, e "." em substituição à variável correspondente ao parâmetro da função

```{r}
map(mtcars, ~ max(.) - min(.))
```

Para encerrarmos o exemplo, poderíamos utilizar a função map_dbl e obter diretamente um vetor numérico em vez de uma lista:

```{r}
map_dbl(mtcars, ~ max(.) - min(.))
```

### Modelos com purrr

Vamos a um exemplo mais interessante, ainda com "mtcars". Nosso objetivo será produzir modelos com pequenas variações a partir de um modelo de regressão linear bastante simples (função lm, "linear model") entre o consumo de combustível de um caso (mpg, "miles per gallon") e seu peso (wt, "weight"), abaixo apresentado:

```{r}
reg <- lm(mpg ~ wt , data = mtcars)

class(reg)
str(reg)
```

O resultado da função lm é um objeto bastante complexo da classe lm. No entanto, trata-se basicamente de uma lista. Podemos extrair seus componentes "navegando" a lista. Por exemplo, para extrairmos os coeficientes gerados no modelo podemos fazer:

```{r}
reg$coefficients

# ou ainda, como nos interessará adiante:
reg[['coefficients']]

#ou mesmo utilizando a posição dos coeficientes na estrutura do objeto:
reg[[1]]
```

Vamos supor que nos interessa agora produzir um modelo para cada categoria de carro em relação ao número de cilindros, que podem ser 4, 6 ou 8. Com a função split, geraremos uma lista de data frames em que cada posição da lista contém um data frame com as observações de uma categoria de número de cilindros.

```{r}
lista_df <- split(mtcars, mtcars$cyl)

lista_df
```

Como gerar, sem repetir várias vezes o código, um modelo para cada um dos data frames na lista de data frames (lembrando que as variáveis dos data frames são exatamente as mesmas)?

Com a função map, obviamente:

```{r}
resultados <- map(lista_df, function(x) lm(mpg ~ wt , data = x))

#Simplificando

resultados <- map(lista_df, ~ lm(mpg ~ wt , data = .))
resultados

```

*"Resultados" recebe para cada uma das listas que estão em lista_df fazer a regressão linear de mpg em relação 'a wt, usando como dado o dado da lista.*

Como resultado você terá a regressão para cada um dos 3 cilindros.

Note que, para cada categoria de número de cilindros, temos agora um objeto da classe "lm". Antes, tinhamos uma lista de data frames. Agora, temos uma lista de resultados da aplicação da função lm a data frames.

Mas o que nos interessa não é observar todo o resultado, mas apenas os coeficientes gerados nos modelos. Podemos, assim aplicar novamente a função map:

```{r}
map(resultados, function(x) x[["coefficients"]])

#Simplificando
map(resultados, "coefficients")

#Vamos guardar os coeficientes em um objeto.
coeficientes <- map(resultados, "coefficients")

#Cada modelo tem 2 coeficientes, o intercepto e o coeficiente angular para a variável "wt". #Procedendo exatamente como acabamos de fazer, podemos extrair apenas os coeficientes de "wt" de #nossa lista:
map(coeficientes, "wt")

# Por termos apenas vetores atômicos em cada posição da lista, poderíamos ter optado por map_dbl # em vez de map:

map_dbl(coeficientes, "wt")

# Finalmente, as funções map pode ser utilizadas com "pipe". O código que produzimos acima pode # ser condensado da seguinte maneira:

mtcars %>% 
  split(mtcars$cyl) %>%
  map(~ lm(mpg ~ wt, data = .)) %>%
  map("coefficients") %>%
  map_dbl("wt")
```

Vamos criar algo novo agora. Vamos supor que queremos produzir o mesmo modelo não para cada categoria de cilindrada, mas incluindo a cada vez apenas um quintil da variável "qsec (tempo que o carro leva para percorrer o primeiro quarto de milha). Ou seja, em primeiro lugar incluiremos apenas 20% carros mais lentos, a seguir os 40% mais lentos, até gerarmos um modelo com todos os carros:

Para gerar os quintis podemos fazer:

```{r}
quintis <- quantile(mtcars$qsec, probs = c(.2, .4, .6, .8, 1))
```

Vamos aplicar a função map ao vetor de quintis (e não ao uma lista de data frames, como anteriormente) para gerar o resultado que nos interessa. Exceto pelas duas primeiras linhas de código, as demais são idênticas à anterior:

```{r}
quintis %>%
  map(~ filter(mtcars, qsec <= .)) %>%
  map(~ lm(mpg ~ wt, data = .)) %>%
  map("coefficients") %>%
  map_dbl("wt")
```

###Combinando data frames em uma lista

Até agora, vimos basicamente a função map do pacote purrr. Vamos examinar rapidamente outra função bastante útil do pacote: reduce.

Um das chatices de trabalharmos com os dados da MUNIC é o fato das informações estarem espalhadas em diversas planilhas de um mesmo documento.

Para o exemplo, temos 3 planilhas que foram exportadas em formato .txt. Em primeiro lugar, vamos abrí-las:

```{r}
munic_v_externa <- read.csv("https://raw.githubusercontent.com/leobarone/FLS6397_2018/master/data/munic_v_externa.csv", sep=";")
munic_r_humanos <- read.csv("https://raw.githubusercontent.com/leobarone/FLS6397_2018/master/data/munic_r_humanos.csv", sep=";")
munic_p_urbano <- read.csv2("https://raw.githubusercontent.com/leobarone/FLS6397_2018/master/data/munic_p_urbano.csv")

# e juntá-las em uma lista.

lista_munic <- list(munic_v_externa, munic_r_humanos, munic_p_urbano )
```

Nosso objetivo agora é combiná-las em um único data frame sem precisar fazer múltiplos "joins". Se estívessemos, por exemplo, trabalhando com dados do TSE, teríamos que combinar 27 data frames em um único e escrever o código das combinações par a par seria pouco inteligente.

Vamos fazer um full_join das 3 planilhas da MUNIC que abrimos pelo id do município (variável A1, comum a todas as planilhas):

```{r}

munic <- lista_munic %>%
  reduce(full_join, by = "A1")

#emocionada
```

Bastante simples, não? A função reduce serve para reduzirmos uma lista a um único objeto. Um exemplo mais simples de aplicação da função seriam:

```{r}
lista <- list(c(1, 1, 2, 3), c(5, 8), 13, c(21, 34))

lista %>% 
  map(sum) %>%
  reduce(`+`)
```

reduce também pode ser utilizado para vetores, e não apenas para listas, como veremos adiante.

###Raspagem de dados com purrr

Vamos a mais uma aplicação interessante das funções do purrr: webscraping. Antes de avançar, precisaremos do pacote rvest.

```{r}
library(rvest)
```

Nosso objetivo será refazer o exemplo da raspagem do DataFolha utilizando a função map em vez de loops. Pegaremos apenas as últimas 25 notícias e, em cada notícia, apenas o texto principal.

Vamos, em primeiro lugar, armazenar o url da página de busca que contém os links para cada notícia:

```{r}
url_base <- "http://search.folha.uol.com.br/search?q=elei%E7%F5es&site=datafolha%2Feleicoes&skin=datafolha"
```

A seguir, vamos raspar os links das 25 notícias. Nada de novo até aqui e você pode fazer essa parte com calma se quiser treinar um pouco mais de webscraping.

```{r}
url_noticia <- url_base %>%
  read_html() %>%
  html_nodes(xpath = "//h2/a") %>%
  html_attr(name = "href")
```

A novidade começa quando queremos repetir um procedimento a um conjunto de páginas. No nosso exemplo, temos 25 links e queremos, em cada um, localizar e extrair o texto da notícia.

Com for loop, fazemos o processo sequencialmente. Agora, porém, podemos aplicar a função read_html a todos os links com a função map e obter como resultado uma lista que contém o código html de todas as páginas:

```{r}
paginas <- url_noticia %>% 
  map(read_html)
```

Na sequência, podemos obter os nodes do corpo das notícias combinando map com html_nodes

```{r}
nodes <- paginas %>% 
  map(~ html_nodes(., xpath = "//article/p"))
```

E, finalmente, podemos extrair os textos dos nodes com map e html_text:

```{r}
textos <- nodes %>%
  map(html_text)
```

Com um pequeno ajuste final, deixamos o texto mais amigável jutandos o vetor de parágrafos de cada texto e um vetor atômico com reduce.

```{r}
textos <- textos %>% 
  reduce(paste)
```

O código completo da raspagem fica:

```{r}
textos <- url_noticia %>% 
  map(read_html) %>%
  map(~ html_nodes(., xpath = "//article/p")) %>%
  map(html_text) %>%
  reduce(paste)


```

